cmdhistory=[";; Switching to clojush.examples.simple-regression namespace" ";; Switching to clojush.experimental.calc namespace" "(+ 1 2)" ";; Switching to clojush.experimental.calc namespace" "(+ 1 2)" "(zip/seq-zip '(1 2))" "(zip/seq-zip '(1 2 ))" "(in-ns 'clojush.util)\\n(defn ensure-list [thing] ;; really make-list-if-not-seq, but close enough for here\\n  (if (seq? thing)\\n    thing\\n    (list thing)))\\n(in-ns 'clojush.experimental.calc)" "(zip/seq-zip '(1 2 ))" ";; Switching to clojush.util namespace" "(not-lazy [1 2 3])" "(zip/seq-zip '(1 2 3))" "(zip/seq-zip 3)" "(defn insert_randomly\\n  [thing tree]\\n  (zip/root\\n    (zip/insert-child (first (take (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))" "(ns clojush.util\\n  (\:require [clojure.math.numeric-tower \:as math]\\n            [clojure.zip \:as zip]\\n            [clojure.walk \:as walk])\\n  (\:use [clojush.globals]\\n        [clojush.random]))" "(defn insert_randomly\\n  [thing tree]\\n  (zip/root\\n    (zip/insert-child (first (take (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))" "(insert-randomly 99 '(1 (2 3) 4))" "(defn insert-randomly\\n  [thing tree]\\n  (zip/root\\n    (zip/insert-child (first (take (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))" "(insert-randomly 99 '(1 (2 3) 4))" "(defn insert-randomly\\n  [thing tree]\\n  (zip/root\\n    (zip/insert-child (first (drop (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))" "(insert-randomly 99 '(1 (2 3) 4))" "(defn insert-randomly\\n  [thing tree]\\n  (zip/root\\n    (zip/insert-left (first (drop (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))" "(insert-randomly 99 '(1 (2 3) 4))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 1)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 2)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 3)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 4)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 5)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 6)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 5)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 6)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root (zip/insert-left (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                                  i 0]\\n                             (if (\= i 5)\\n                               z\\n                               (recur (zip/next z) \\n                                      (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 5)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 0)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 1)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 2)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 3)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 4)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 5)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip 0);'(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 5)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip 0);'(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 1)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip 0);'(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 0)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(0));'(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 0)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(0));'(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 1)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n                           99))" "(defn insert-randomly\\n  [thing place]\\n  (let [tree (ensure-list place)\\n        loc ]\\n    (zip/root\\n      ((lrand-nth [zip/insert-left zip/insert-right])\\n        (loop [z (zip/seq-zip tree) i 0]\\n          (if (\= i \\n                   \\n                   (first (drop (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))\\n\\n(insert-randomly 99 '(1 (2 3) 4))\\n\\n(count-points '(1 (2 3) 4))\\n\\n(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(0));'(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 1)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n            99))" "(count-points '(1 (2 3) 4))" "(defn insert-randomly\\n  [thing place]\\n  (let [tree (ensure-list place)\\n        loc ]\\n    (zip/root\\n      ((lrand-nth [zip/insert-left zip/insert-right])\\n        (loop [z (zip/seq-zip tree) i 0]\\n          (if (\= i \\n                   \\n                   (first (drop (lrand-int (count-points tree))\\n                                   (iterate zip/next (zip/seq-zip tree))))\\n                      thing)))\\n\\n(insert-randomly 99 '(1 (2 3) 4))\\n\\n(count-points '(1 (2 3) 4))\\n\\n(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 1)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n            99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 1)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n            99))" "(zip/root ((lrand-nth [zip/insert-left zip/insert-right])\\n            (loop [z (zip/seq-zip '(1 (2 3) 4))\\n                   i 0]\\n              (if (\= i 5)\\n                z\\n                (recur (zip/next z) \\n                       (inc i))))\\n            99))" "(insert-randomly 99 '(1 (2 3) 4))" "(defn insert-randomly\\n  [thing place]\\n  (let [tree (ensure-list place)\\n        loc (inc (lrand-int (dec (count-points tree))))]\\n    (zip/root\\n      ((lrand-nth [zip/insert-left zip/insert-right])\\n        (loop [z (zip/seq-zip tree) i 0]\\n          (if (\= i loc)\\n            z\\n            (recur (zip/next z) (inc i))))\\n        thing))))" "(insert-randomly 99 '(1 (2 3) 4))" "(defn insert-randomly\\n  \\"Returns lst with thing inserted in a random location. If lst is not a list then\\nit will first be wrapped in a list.\\"\\n  [thing lst]\\n  (let [tree (ensure-list lst)\\n        loc (inc (lrand-int (dec (count-points tree))))]\\n    (zip/root\\n      ((lrand-nth [zip/insert-left zip/insert-right])\\n        (loop [z (zip/seq-zip tree) i 0]\\n          (if (\= i loc)\\n            z\\n            (recur (zip/next z) (inc i))))\\n        thing))))" ";; Switching to clojush.instructions.tag namespace" ";; Switching to clojush.experimental.calc namespace" "(.bs)" ";; Switching to clojush.experimental.calc namespace" "(bt)" "(.printStackTrace *e)" "(+ 1 2)" ";; Switching to clojush.pushgp.genetic-operators namespace" "(+ 1 2)" "(list? '(1 2 3))" "(list? (concat '(1 2 3) ()))" "(list? (apply list (concat '(1 2 3) ())))" "(apply list (concat '(1 2 3) ()))" "\\n(defn remove-empties \\n  \\"Removes empty sequences from tree t.\\"\\n  [t]\\n  (clojure.walk/postwalk \\n    (fn [node] (if (seq? node) \\n                 (remove \#(and (seq? %) (empty? %)) node)\\n                 node))\\n    t))\\n\\n(defn combine [t1 t2] \\n  \\"Returns a list containing all of the elements of t1 and t2, after making each into\\na list if necessary.\\"\\n  (apply list (concat (ensure-list t1) (ensure-list t2))))\\n\\n\#_(defn one-or-the-other-or-both [t1 t2]\\n  (lrand-nth (concat (repeat 16 t1)\\n                     [t2 t2 (combine t1 t2) (combine t2 t1) \\n                      () () () ()])))                     \\n\\n(defn one-or-the-other-or-both-or-neither [t1 t2]\\n  (lrand-nth [t1 t1 t2 t2 (combine t1 t2) (combine t2 t1) () ()]))" "(defn amalgamate\\n  [t1 t2]\\n  (remove-empties\\n    (if (or (null? t1)\\n            (not (seq? t1))\\n            (null? t2))\\n      (one-or-the-other-or-both-or-neither t1 t2)\\n      (map amalgamate \\n           t1 \\n           (if (seq? t2) \\n             (cycle t2) \\n             (cycle [t2]))))))" "(empty? 3)" "null?" "(defn null? [thing] (and (seq? thing) (empty? thing)))" "(defn amalgamate\\n  [t1 t2]\\n  (remove-empties\\n    (if (or (null? t1)\\n            (not (seq? t1))\\n            (null? t2))\\n      (one-or-the-other-or-both-or-neither t1 t2)\\n      (map amalgamate \\n           t1 \\n           (if (seq? t2) \\n             (cycle t2) \\n             (cycle [t2]))))))" "(defn null? [thing] (and (seq? thing) (empty? thing)))" "(amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '(1 (2 ((3 4) 5) 6 (7 8 9 (10 11 12) ((13 14 15 16 17 18) 19 20 21 22 ((23) 24 25 26))))))" "(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))" "(amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '(1 (2 ((3 4) 5) 6 (7 8 9 (10 11 12) ((13 14 15 16 17 18) 19 20 21 22 ((23) 24 25 26))))))" "(.upCase \\"(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\")" "(string/uppercase \\"(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\")" "(use 'clojure.string)" "(upper-case \\"(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\")" "(amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '(A (B ((C D) E) F (G H I (J K L) ((M N O P Q R) S T U V ((W) X Y Z))))))" "(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))" "(amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(do \\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println (amalgamate \\n             '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n             '(A (B ((C D) E) F (G H I (J K L) ((M N O P Q R) S T U V ((W) X Y Z))))))))" "(list? ())" ";; Switching to clojush.pushgp.genetic-operators namespace" "(do \\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println (amalgamate \\n             '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n             '(A (B ((C D) E) F (G H I (J K L) ((M N O P Q R) S T U V ((W) X Y Z))))))))" "(defn self-or-other-or-both-or-neither [self other]\\n  (let [n (lrand)]\\n    (cond (< n {\:self global-amalgamation-parameters}) self\\n          (< n (+ (\:self global-amalgamation-parameters)\\n                  (\:other global-amalgamation-parameters))) other\\n          (< n (+ (\:self global-amalgamation-parameters)\\n                  (\:other global-amalgamation-parameters)\\n                  (\:self-other global-amalgamation-parameters))) (list self other)\\n          (< n (+ (\:self global-amalgamation-parameters)\\n                  (\:other global-amalgamation-parameters)\\n                  (\:self-other global-amalgamation-parameters)\\n                  (\:other-self global-amalgamation-parameters))) (list other self)\\n          \:else ())))" "(do \\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println (amalgamate \\n             '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n             '(A (B ((C D) E) F (G H I (J K L) ((M N O P Q R) S T U V ((W) X Y Z))))))))" "(defn amalgamation-crossover \\n  \\"Amalgamation.\\"\\n  [parent1 parent2 max-points]\\n  (let [new-program (if (< (lrand) 0.0)\\n                      (insert-code-at-point \\n                        (\:program parent1) \\n                        (select-node-index (\:program parent1))\\n                        (code-at-point (\:program parent2)\\n                                       (select-node-index (\:program parent2))))\\n                      (amalgamate (\:program parent1) (\:program parent2)))]\\n    (if (> (count-points new-program) max-points)\\n      parent1\\n      (make-individual \:program new-program \:history (\:history parent1)\\n                       \:ancestors (if maintain-ancestors\\n                                    (cons (\:program parent1) (\:ancestors parent1))\\n                                    (\:ancestors parent1))))))" "(do \\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (amalgamate '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(do \\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println (amalgamate \\n             '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n             '(A (B ((C D) E) F (G H I (J K L) ((M N O P Q R) S T U V ((W) X Y Z))))))))" ";; Switching to clojush.experimental.calc namespace" "(.printStackTrace *e)" "(amalgamate '(1 2 3) '(3 4 5))" "(amalgamate 1 2)" "(amalgamate () 1)" "(amalgamate 2 ())" ";; Switching to clojush.globals namespace" "(/ 0.0125 2)" "(reduce + (vals {\:self 0.95 \:other 0.025 \:self-other 0.00625 \:other-self 0.00625 \:nothing 0.0225}))" "(reduce + (vals {\:self 0.95 \:other 0.025 \:self-other 0.00625 \:other-self 0.00625 \:nothing 0.0125}))" ";; Switching to clojush.experimental.calc namespace" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'clojush.experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties\\n    (let [choice-point (lrand)]\\n      (cond (or (not (seq? t1)) (empty? t1))\\n            (or (not (seq? t2)) (empty? t2))\\n    \\n    (if (or (null? t1)\\n            (not (seq? t1))\\n            (null? t2))\\n      (self-or-other-or-both-or-neither t1 t2 @global-hybridization-parameters)\\n      (map hybridize t1 (pad-to-length (count t1) t2)))))\\n    \\n    \\n(defn shmix ;; stochastic hierarchical mixing \\n  [self other params]\\n  (let [w (\:whole params)\\n        pf (\:pair-function params)\\n        s (\:self params)\\n        o (\:other params)\\n        m (\:mix params)\\n        mf (\:mix-function params)\\n        ; \\"neither\\" is implicitly 1.0 - s - o - m\\n        ]\\n    (if (and (seq? self)\\n             (not (empty? self))\\n             (>\= (lrand) w))\\n      ;; decompose\\n      (map (fn [[self-part other-part]]\\n             (schmix self-part other-part params))\\n           (pf self other))\\n      ;; don't decompose\\n      (....)\\n)))\\n\\n\\n(defn schmix\\n  [self other params]\\n  (if (and (seq? self)\\n           (not (empty? self))\\n           (> (lrand) (\:whole params)))\\n    (map (fn [[t1 t2]] ((\:mix-function params) t1 t2 params))\\n         ((\:pair-function params) self other))\\n    ((\:mix-function params) self other params)))\\n(in-ns 'clojush.experimental.calc)" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties\\n    (let [choice-point (lrand)]\\n      (cond (or (not (seq? t1)) (empty? t1))\\n            (or (not (seq? t2)) (empty? t2))\\n    \\n    (if (or (null? t1)\\n            (not (seq? t1))\\n            (null? t2))\\n      (self-or-other-or-both-or-neither t1 t2 @global-hybridization-parameters)\\n      (map hybridize t1 (pad-to-length (count t1) t2)))))\\n    \\n    \\n;(defn shmix ;; stochastic hierarchical mixing \\n;  [self other params]\\n;  (let [w (\:whole params)\\n;        pf (\:pair-function params)\\n;        s (\:self params)\\n;        o (\:other params)\\n;        m (\:mix params)\\n;        mf (\:mix-function params)\\n;        ; \\"neither\\" is implicitly 1.0 - s - o - m\\n;        ]\\n;    (if (and (seq? self)\\n;             (not (empty? self))\\n;             (>\= (lrand) w))\\n;      ;; decompose\\n;      (map (fn [[self-part other-part]]\\n;             (schmix self-part other-part params))\\n;           (pf self other))\\n;      ;; don't decompose\\n;      (....)\\n;)))\\n\\n\\n(defn schmix\\n  [self other params]\\n  (if (and (seq? self)\\n           (not (empty? self))\\n           (> (lrand) (\:whole params)))\\n    (map (fn [[t1 t2]] ((\:mix-function params) t1 t2 params))\\n         ((\:pair-function params) self other))\\n    ((\:mix-function params) self other params)))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties\\n    (let [choice-point (lrand)]\\n      (cond (or (not (seq? t1)) (empty? t1))\\n            (or (not (seq? t2)) (empty? t2))\\n    \\n    (if (or (null? t1)\\n            (not (seq? t1))\\n            (null? t2))\\n      (self-or-other-or-both-or-neither t1 t2 @global-hybridization-parameters)\\n      (map hybridize t1 (pad-to-length (count t1) t2)))))\\n    \\n    \\n;(defn shmix ;; stochastic hierarchical mixing \\n;  [self other params]\\n;  (let [w (\:whole params)\\n;        pf (\:pair-function params)\\n;        s (\:self params)\\n;        o (\:other params)\\n;        m (\:mix params)\\n;        mf (\:mix-function params)\\n;        ; \\"neither\\" is implicitly 1.0 - s - o - m\\n;        ]\\n;    (if (and (seq? self)\\n;             (not (empty? self))\\n;             (>\= (lrand) w))\\n;      ;; decompose\\n;      (map (fn [[self-part other-part]]\\n;             (schmix self-part other-part params))\\n;           (pf self other))\\n;      ;; don't decompose\\n;      (....)\\n;)))\\n\\n\\n(defn schmix\\n  [self other params]\\n  (if (and (seq? self)\\n           (not (empty? self))\\n           (> (lrand) (\:whole params)))\\n    (map (fn [[t1 t2]] ((\:mix-function params) t1 t2 params))\\n         ((\:pair-function params) self other))\\n    ((\:mix-function params) self other params)))\\n\\n(schmix '(a (b c) d) \\n        '(1 2 (3 4 (5)))\\n        {\:whole 0.1 \\n         \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n         \:pair-function (fn [source1 source2] \\n                          ;; pair elts of 1st with elts of ()-padded 2nds\\n                          (map vector \\n                               (ensure-list source1) \\n                               (concat (ensure-list source2) \\n                                       (repeat ()))))\\n         \:mix-function (fn [whole1 whole2 params]\\n                         (let [i (lrand-int)]\\n                           (cond (< i (\:self params)) whole1\\n                                 (< i (+ (\:self param) \\n                                         (\:other params))) whole2\\n                                 (< i (+ (\:self param) \\n                                         (\:other params) \\n                                         (\:mix params))) (if (< (lrand) 0.5)\\n                                                           (combine whole1 whole2)\\n                                                           (combine whole2 whole1))\\n                                 ; nothing is implicit\\n                                 \:else ())))})" ";; Switching to clojush.pushgp.genetic-operators namespace" "(println\\n  \\n(schmix '(a (b c) d) \\n        '(1 2 (3 4 (5)))\\n        {\:whole 0.1 \\n         \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n         \:pair-function (fn [source1 source2] \\n                          ;; pair elts of 1st with elts of ()-padded 2nds\\n                          (map vector \\n                               (ensure-list source1) \\n                               (concat (ensure-list source2) \\n                                       (repeat ()))))\\n         \:mix-function (fn [whole1 whole2 params]\\n                         (let [i (lrand-int)]\\n                           (cond (< i (\:self params)) whole1\\n                                 (< i (+ (\:self params) \\n                                         (\:other params))) whole2\\n                                 (< i (+ (\:self params) \\n                                         (\:other params) \\n                                         (\:mix params))) (if (< (lrand) 0.5)\\n                                                           (combine whole1 whole2)\\n                                                           (combine whole2 whole1))\\n                                 ; nothing is implicit\\n                                 \:else ())))})\\n\\n  )" "(println\\n  (schmix '(a (b c) d) \\n        '(1 2 (3 4 (5)))\\n        {\:whole 0.1 \\n         \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n         \:pair-function (fn [source1 source2] \\n                          ;; pair elts of 1st with elts of ()-padded 2nds\\n                          (map vector \\n                               (ensure-list source1) \\n                               (concat (ensure-list source2) \\n                                       (repeat ()))))\\n         \:mix-function (fn [whole1 whole2 params]\\n                         (let [i (lrand-int)]\\n                           (cond (< i (\:self params)) whole1\\n                                 (< i (+ (\:self params) \\n                                         (\:other params))) whole2\\n                                 (< i (+ (\:self params) \\n                                         (\:other params) \\n                                         (\:mix params))) (if (< (lrand) 0.5)\\n                                                           (combine whole1 whole2)\\n                                                           (combine whole2 whole1))\\n                                 ; nothing is implicit\\n                                 \:else ())))})\\n)" "(schmix '(a (b c) d) \\n        '(1 2 (3 4 (5)))\\n        {\:whole 0.1 \\n         \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n         \:pair-function (fn [source1 source2] \\n                          ;; pair elts of 1st with elts of ()-padded 2nds\\n                          (map vector \\n                               (ensure-list source1) \\n                               (concat (ensure-list source2) \\n                                       (repeat ()))))\\n         \:mix-function (fn [whole1 whole2 params]\\n                         (let [i (lrand-int)]\\n                           (cond (< i (\:self params)) whole1\\n                                 (< i (+ (\:self params) \\n                                         (\:other params))) whole2\\n                                 (< i (+ (\:self params) \\n                                         (\:other params) \\n                                         (\:mix params))) (if (< (lrand) 0.5)\\n                                                           (combine whole1 whole2)\\n                                                           (combine whole2 whole1))\\n                                 ; nothing is implicit\\n                                 \:else ())))})" "(.printStackTrace *e)" "(schmix '(a (b c) d) \\n        '(1 2 (3 4 (5)))\\n        {\:whole 0.1 \\n         \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n         \:pair-function (fn [source1 source2] \\n                          ;; pair elts of 1st with elts of ()-padded 2nds\\n                          (map vector \\n                               (ensure-list source1) \\n                               (concat (ensure-list source2) \\n                                       (repeat ()))))\\n         \:mix-function (fn [whole1 whole2 params]\\n                         (let [i (lrand)]\\n                           (cond (< i (\:self params)) whole1\\n                                 (< i (+ (\:self params) \\n                                         (\:other params))) whole2\\n                                 (< i (+ (\:self params) \\n                                         (\:other params) \\n                                         (\:mix params))) (if (< (lrand) 0.5)\\n                                                           (combine whole1 whole2)\\n                                                           (combine whole2 whole1))\\n                                 ; nothing is implicit\\n                                 \:else ())))})" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {\:whole 0.1 \\n             \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))" "(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "0.01" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.01\\n             \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))" "(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.01\\n             \:self 0.5 \:other 0.2 \:mix 0.2 \:nothing 0.1 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))" "(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.1\\n             \:self 0.5 \:other 0.2 \:mix 0.2 \:nothing 0.1 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))" "(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "button-entrypoints" "(in-ns 'clojush.experimental.calc)\\n(def calc-tests\\n  ;; [inputs answer error]\\n  ;; answer doesn't matter if error is true\\n  ;; if no error, answer must be correct on float stack and true cannot be top boolean\\n  [;[[\:one \:divided-by \:zero \:equals] 0.0 true]\\n   [[\:one] 1.0 false]\\n   ;[[\:one \:plus] 1.0 false]\\n   ;[[\:one \:plus \:one] 1.0 false]\\n   ;[[\:one \:plus \:one \:equals] 2.0 false]\\n   ;[[\:two \:plus \:two \:equals] 4.0 false]\\n   ;[[\:nine \:times \:nine \:equals] 81.0 false]\\n   ;[[\:three \:divided-by \:four \:equals] 0.75 false]\\n   ;[[\:one \:two \:three \:four \:five \:plus \:six \:seven \:eight \:nine \:zero \:equals] 80235.0 false]\\n   ;[[\:one \:point \:two \:three \:times \:four \:point \:five \:six \:equals] 5.6088 false]\\n   ;[[\:on-clear] 0.0 false]\\n   ;[[\:nine \:nine \:nine \:on-clear] 0.0 false]\\n   ;[[\:one \:point \:two] 1.2 false]\\n   ;[[\:one \:point \:two \:point \:three \:point \:four] 1.234 false]\\n   ;[[\:one \:point \:two \:plus \:three \:point \:four \:equals] 4.6 false]\\n   ;[[\:one \:point \:two \:times \:three \:point \:four \:equals] 4.08 false]\\n   ;[[\:one \:point \:two \:divided-by \:two \:equals] 0.6 false]\\n   [[\:two] 2.0 false]\\n   [[\:three] 3.0 false]\\n   [[\:four] 4.0 false]\\n   [[\:five] 5.0 false]\\n   [[\:six] 6.0 false]\\n   [[\:seven] 7.0 false]\\n   [[\:eight] 8.0 false]\\n   [[\:nine] 9.0 false]\\n   [[\:zero] 0.0 false]\\n   [[\:one \:one] 11.0 false]\\n   [[\:one \:one \:one] 111.0 false]\\n   [[\:one \:one \:one \:one] 1111.0 false]\\n   [[\:one \:one \:one \:one \:one] 11111.0 false]\\n   [[\:one \:two] 12.0 false]\\n   [[\:three \:four \:five] 345.0 false]\\n   [[\:six \:seven \:eight \:nine] 6789.0 false]\\n   ;[[\:two \:two \:plus \:two \:two \:equals] 44.0 false]\\n   ])\\n(in-ns 'clojush.pushgp.genetic-operators)" "(def calc-tests\\n  ;; [inputs answer error]\\n  ;; answer doesn't matter if error is true\\n  ;; if no error, answer must be correct on float stack and true cannot be top boolean\\n  [;[[\:one \:divided-by \:zero \:equals] 0.0 true]\\n   [[\:one] 1.0 false]\\n   ;[[\:one \:plus] 1.0 false]\\n   ;[[\:one \:plus \:one] 1.0 false]\\n   ;[[\:one \:plus \:one \:equals] 2.0 false]\\n   ;[[\:two \:plus \:two \:equals] 4.0 false]\\n   ;[[\:nine \:times \:nine \:equals] 81.0 false]\\n   ;[[\:three \:divided-by \:four \:equals] 0.75 false]\\n   ;[[\:one \:two \:three \:four \:five \:plus \:six \:seven \:eight \:nine \:zero \:equals] 80235.0 false]\\n   ;[[\:one \:point \:two \:three \:times \:four \:point \:five \:six \:equals] 5.6088 false]\\n   ;[[\:on-clear] 0.0 false]\\n   ;[[\:nine \:nine \:nine \:on-clear] 0.0 false]\\n   ;[[\:one \:point \:two] 1.2 false]\\n   ;[[\:one \:point \:two \:point \:three \:point \:four] 1.234 false]\\n   ;[[\:one \:point \:two \:plus \:three \:point \:four \:equals] 4.6 false]\\n   ;[[\:one \:point \:two \:times \:three \:point \:four \:equals] 4.08 false]\\n   ;[[\:one \:point \:two \:divided-by \:two \:equals] 0.6 false]\\n   [[\:two] 2.0 false]\\n   [[\:three] 3.0 false]\\n   [[\:four] 4.0 false]\\n   [[\:five] 5.0 false]\\n   [[\:six] 6.0 false]\\n   [[\:seven] 7.0 false]\\n   [[\:eight] 8.0 false]\\n   [[\:nine] 9.0 false]\\n   [[\:zero] 0.0 false]\\n   [[\:one \:one] 11.0 false]\\n   [[\:one \:one \:one] 111.0 false]\\n   [[\:one \:one \:one \:one] 1111.0 false]\\n   [[\:one \:one \:one \:one \:one] 11111.0 false]\\n   [[\:one \:two] 12.0 false]\\n   [[\:three \:four \:five] 345.0 false]\\n   [[\:six \:seven \:eight \:nine] 6789.0 false]\\n   ;[[\:two \:two \:plus \:two \:two \:equals] 44.0 false]\\n   ])" "button-entrypoints" "(def buttons\\n  [\:percent       \:square-root  \:off         \:on-clear\\n   \:memory-recall \:memory-minus \:memory-plus \:clear-entry\\n   \:seven         \:eight        \:nine        \:divided-by\\n   \:four          \:five         \:six         \:times\\n   \:one           \:two          \:three       \:minus\\n   \:zero          \:point        \:equals      \:plus])" "(def button-entrypoints\\n  (zipmap buttons (iterate \#(+ % 100) 0)))" "(ns experimental.calc\\n  (\:use [clojush.pushgp.pushgp]\\n        [clojush.pushstate]\\n        [clojush.interpreter]\\n        [clojush.random]\\n        [clojush.util]\\n        [clojush.instructions.tag]\\n        [clojure.math.numeric-tower]))" "(in-ns 'clojush.experimental.calc)\\n(def button-entrypoints\\n  (zipmap buttons (iterate \#(+ % 100) 0)))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn shmix\\n  [self other params]\\n  (if (and (seq? self)\\n           (not (empty? self))\\n           (> (lrand) (\:whole params)))\\n    (map (fn [[t1 t2]] ((\:mix-function params) t1 t2 params))\\n         ((\:pair-function params) self other))\\n    ((\:mix-function params) self other params)))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.0 ; 0.1\\n             \:self 0.5 \:other 0.2 \:mix 0.2 \:nothing 0.1 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.0 ; 0.1\\n             \:self 0.5 \:other 0.2 \:mix 0.2 \:nothing 0.1 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 1.0 ; 0.1\\n             \:self 0.5 \:other 0.2 \:mix 0.2 \:nothing 0.1 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.5\\n             \:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (schmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.25\\n             \:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n             '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n            t2\\n            {;\:whole 0.1 \\n             ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n             \:whole 0.25\\n             \:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n             \:pair-function (fn [source1 source2] \\n                              ;; pair elts of 1st with elts of ()-padded 2nds\\n                              (map vector \\n                                   (ensure-list source1) \\n                                   (concat (ensure-list source2) \\n                                           (repeat ()))))\\n             \:mix-function (fn [whole1 whole2 params]\\n                             (let [i (lrand)]\\n                               (cond (< i (\:self params)) whole1\\n                                     (< i (+ (\:self params) \\n                                             (\:other params))) whole2\\n                                     (< i (+ (\:self params) \\n                                             (\:other params) \\n                                             (\:mix params))) (if (< (lrand) 0.5)\\n                                                               (combine whole1 whole2)\\n                                                               (combine whole2 whole1))\\n                                     ; nothing is implicit\\n                                     \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {;\:whole 0.1 \\n            ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n            \:whole 0.25\\n            \:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (hybridize '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n             '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn shmix\\n  [self other params]\\n  (if (and (seq? self)\\n           (not (empty? self))\\n           (> (lrand) (\:whole params)))\\n    (map (fn [[t1 t2]] (shmix t1 t2 params))\\n         ((\:pair-function params) self other))\\n    ((\:mix-function params) self other params)))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {;\:whole 0.1 \\n            ;\:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n            \:whole 0.25\\n            \:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))\\n(in-ns 'experimental.calc)" "(in-ns 'clojush.pushgp.genetic-operators)\\n(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))\\n(in-ns 'experimental.calc)" ";; Switching to clojush.pushgp.genetic-operators namespace" "(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole 0.1 \\n            \:self 0.95 \:other 0.025 \:mix 0.0125 \:nothing 0.0125 \\n            ;\:whole 0.25 \:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole 0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(defn hybridize-print \\n  [a b]\\n  (println \\"b      \:\\" b)\\n  (println \\"a      \:\\" a)\\n  (println \\"hyb a b\:\\" (hybrizize a b)))" "(defn hybridize-print \\n  [a b]\\n  (println \\"b      \:\\" b)\\n  (println \\"a      \:\\" a)\\n  (println \\"hyb a b\:\\" (hybridize a b)))" "(do ;; print self first for comparison\\n  (println '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))\\n  (println '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))\\n  (hybridize '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n            '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(hybridize-print (random-code 500 [1])\\n                 (random-code 500 [0]))" "(hybridize-print (random-code 1000 [1])\\n                 (random-code 1000 [0]))" "(hybridize-print (random-code-with-size 1000 [1])\\n                 (random-code-with-size 1000 [0]))" "(hybridize-print (random-code-with-size 10000 [1])\\n                 (random-code-with-size 10000 [0]))" "(hybridize-print (random-code-with-size 100 [1])\\n                 (random-code-with-size 100 [0]))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (count-points t1)) ;0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 0.1 (count-points t1)) ;0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(defn hybridize-print \\n  [a b]\\n  (println \\"b      \:\\" b)\\n  (println \\"a      \:\\" a)\\n  (println \\"hyb a b\:\\" (hybridize a b)))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole 1; (/ 0.1 (count-points t1)) ;0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole 0; (/ 0.1 (count-points t1)) ;0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole 1; (/ 0.1 (count-points t1)) ;0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (count-points t1)) ;0.1 \\n            \:self 0.7 \:other 0.1 \:mix 0.1 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (count-points t1)) ;0.1 \\n            \:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (count-points t1)) ;0.1 \\n            ;\:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n            \:self 0.75 \:other 0.025 \:mix 0.2 \:nothing 0.025\\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn combine [t1 t2] \\n  \\"If one argument is () then returns the other. Othewise returns a list containing \\nall of the elements of t1 and t2, after making each into a list if necessary.\\"\\n  (cond (\= t1 ()) t2\\n        (\= t2 ()) t1\\n        (apply list (concat (ensure-list t1) (ensure-list t2)))))" "(defn combine [t1 t2] \\n  \\"If one argument is () then returns the other. Othewise returns a list containing \\nall of the elements of t1 and t2, after making each into a list if necessary.\\"\\n  (cond (\= t1 ()) t2\\n        (\= t2 ()) t1\\n        \:else (apply list (concat (ensure-list t1) (ensure-list t2)))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (count-points t1)) ;0.1 \\n            ;\:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n            \:self 0.5 \:other 0.125 \:mix 0.25 \:nothing 0.125\\n            ;\:whole 0.25 \\n            ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [i (lrand)]\\n                              (cond (< i (\:self params)) whole1\\n                                    (< i (+ (\:self params) \\n                                            (\:other params))) whole2\\n                                    (< i (+ (\:self params) \\n                                            (\:other params) \\n                                            (\:mix params))) (if (< (lrand) 0.5)\\n                                                              (combine whole1 whole2)\\n                                                              (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1pts (count-points t1)\\n        t2pts (count-points t2)\\n        pts-ratio (/ t1pts t2pts)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1pts) ;0.1 \\n              ;\:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n              ;\:self 0.5 \:other 0.125 \:mix 0.25 \:nothing 0.125\\n              \:self pts-ratio \:other (/ (- 1 pts-ratio) 2) \:mix (/ (- 1 pts-ratio) 4) \:nothing (/ (- 1 pts-ratio) 4)\\n              ;\:whole 0.25 \\n              ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [i (lrand)]\\n                                (cond (< i (\:self params)) whole1\\n                                      (< i (+ (\:self params) \\n                                              (\:other params))) whole2\\n                                      (< i (+ (\:self params) \\n                                              (\:other params) \\n                                              (\:mix params))) (if (< (lrand) 0.5)\\n                                                                (combine whole1 whole2)\\n                                                                (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(count-points ())" "(defn hybridize\\n  [t1 t2]\\n  (let [t1pts (count-points t1)\\n        t2pts (count-points t2)\\n        pts-ratio (/ t1pts t2pts)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1pts) ;0.1 \\n              ;\:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n              ;\:self 0.5 \:other 0.125 \:mix 0.25 \:nothing 0.125\\n              \:self pts-ratio \:other (/ (- 1 pts-ratio) 2) \:mix (/ (- 1 pts-ratio) 4) \:nothing (/ (- 1 pts-ratio) 4)\\n              ;\:whole 0.25 \\n              ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [i (lrand)]\\n                                (cond (< i (\:self params)) whole1\\n                                      (< i (+ (\:self params) \\n                                              (\:other params))) whole2\\n                                      (< i (+ (\:self params) \\n                                              (\:other params) \\n                                              (\:mix params))) (if (< (lrand) 0.5)\\n                                                                (combine whole1 whole2)\\n                                                                (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(defn atoms [thing] (count (flatten (ensure-list thing))))" "(atoms ())" "(atoms 1)" "(atoms '(1 2 ()))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1pts (count-points t1)\\n        t2pts (count-points t2)\\n        pts-ratio (/ t2pts t1pts)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1pts) ;0.1 \\n              ;\:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n              ;\:self 0.5 \:other 0.125 \:mix 0.25 \:nothing 0.125\\n              \:self (- 1 pts-ratio) \:other (/ pts-ratio 2)\:mix (/ pts-ratio 4) \:nothing (/ pts-ratio 4)\\n              ;\:whole 0.25 \\n              ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [i (lrand)]\\n                                (cond (< i (\:self params)) whole1\\n                                      (< i (+ (\:self params) \\n                                              (\:other params))) whole2\\n                                      (< i (+ (\:self params) \\n                                              (\:other params) \\n                                              (\:mix params))) (if (< (lrand) 0.5)\\n                                                                (combine whole1 whole2)\\n                                                                (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1pts (atoms t1)\\n        t2pts (atoms t2)\\n        pts-ratio (/ t2pts t1pts)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1pts) ;0.1 \\n              ;\:self 0.6 \:other 0.1 \:mix 0.2 \:nothing 0.1 \\n              ;\:self 0.5 \:other 0.125 \:mix 0.25 \:nothing 0.125\\n              \:self (- 1 pts-ratio) \:other (/ pts-ratio 2)\:mix (/ pts-ratio 4) \:nothing (/ pts-ratio 4)\\n              ;\:whole 0.25 \\n              ;\:self 0.25 \:other 0.25 \:mix 0.25 \:nothing 0.25 \\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [i (lrand)]\\n                                (cond (< i (\:self params)) whole1\\n                                      (< i (+ (\:self params) \\n                                              (\:other params))) whole2\\n                                      (< i (+ (\:self params) \\n                                              (\:other params) \\n                                              (\:mix params))) (if (< (lrand) 0.5)\\n                                                                (combine whole1 whole2)\\n                                                                (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "1/2" "(+ 1/2 2/3)" "(defn hybridize\\n  [t1 t2 t1-bias]\\n  (let [t1pts (atoms t1)\\n        t2pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1pts total-pts)\\n        proportion-in-t2 (/ t2pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(defn hybridize\\n  [t1 t2 t1-bias]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1pts total-pts)\\n        proportion-in-t2 (/ t2pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(defn hybridize\\n  [t1 t2 t1-bias]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1pts total-pts)\\n        proportion-in-t2 (/ t2pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1-pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(defn hybridize\\n  [t1 t2 t1-bias]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1-pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1-pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole 0 ;(/ 1 t1-pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)\\n        t1-stays (< (lrand) proportion-in-t1)\\n        t2-stays (< (lrand) proportion-in-t2)]\\n    (println t1-pts t2-pts total-pts proportion-in-t1 proportion-in-t2 t1-stays t2-stays)\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole 0 ;(/ 1 t1-pts) \\n              \:self t1-stays \:other t2-stays\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (cond (and (\:self params) \\n                                         (not (\:other params))) whole1\\n                                    (and (not (\:self params)) \\n                                         (\:other params)) whole2\\n                                    (and (\:self params) \\n                                         (\:other params)) (if (< (lrand) 0.5)\\n                                                            (combine whole1 whole2)\\n                                                            (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ()))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)]\\n    (println t1-pts t2-pts total-pts proportion-in-t1 proportion-in-t2 t1-stays t2-stays)\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole 0 ;(/ 1 t1-pts) \\n              \:self proportion-in-t1 \:other proportion-in-t2\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [include-1 (< (lrand) (\:self params))\\n                                    include-2 (< (lrand) (\:other params))]\\n                                (cond (and include-1\\n                                           (not include-2)) whole1\\n                                      (and (not include-1) \\n                                           include-2) whole2\\n                                      (and include-1\\n                                           include-2) (if (< (lrand) 0.5)\\n                                                        (combine whole1 whole2)\\n                                                        (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)]\\n    (println t1-pts t2-pts total-pts proportion-in-t1 proportion-in-t2)\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole 0 ;(/ 1 t1-pts) \\n              \:self proportion-in-t1 \:other proportion-in-t2\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [include-1 (< (lrand) (\:self params))\\n                                    include-2 (< (lrand) (\:other params))]\\n                                (cond (and include-1\\n                                           (not include-2)) whole1\\n                                      (and (not include-1) \\n                                           include-2) whole2\\n                                      (and include-1\\n                                           include-2) (if (< (lrand) 0.5)\\n                                                        (combine whole1 whole2)\\n                                                        (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole 0 ;(/ 1 t1-pts) \\n              \:self proportion-in-t1 \:other proportion-in-t2\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [include-1 (< (lrand) (\:self params))\\n                                    include-2 (< (lrand) (\:other params))]\\n                                (cond (and include-1\\n                                           (not include-2)) whole1\\n                                      (and (not include-1) \\n                                           include-2) whole2\\n                                      (and include-1\\n                                           include-2) (if (< (lrand) 0.5)\\n                                                        (combine whole1 whole2)\\n                                                        (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1-pts) \\n              \:self proportion-in-t1 \:other proportion-in-t2\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [include-1 (< (lrand) (\:self params))\\n                                    include-2 (< (lrand) (\:other params))]\\n                                (cond (and include-1\\n                                           (not include-2)) whole1\\n                                      (and (not include-1) \\n                                           include-2) whole2\\n                                      (and include-1\\n                                           include-2) (if (< (lrand) 0.5)\\n                                                        (combine whole1 whole2)\\n                                                        (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)\\n        t1-bias 0.9]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1-pts) \\n              \:self (+ proportion-in-t1 (* t1-bias proportion-in-t2)) \:other (* (- 1 t1-bias) proportion-in-t2)\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [include-1 (< (lrand) (\:self params))\\n                                    include-2 (< (lrand) (\:other params))]\\n                                (cond (and include-1\\n                                           (not include-2)) whole1\\n                                      (and (not include-1) \\n                                           include-2) whole2\\n                                      (and include-1\\n                                           include-2) (if (< (lrand) 0.5)\\n                                                        (combine whole1 whole2)\\n                                                        (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (let [t1-pts (atoms t1)\\n        t2-pts (atoms t2)\\n        total-pts (+ t1-pts t2-pts)\\n        proportion-in-t1 (/ t1-pts total-pts)\\n        proportion-in-t2 (/ t2-pts total-pts)\\n        t1-bias 0.5]\\n    (remove-empties \\n      (shmix t1\\n             t2\\n             {\:whole (/ 1 t1-pts) \\n              \:self (+ proportion-in-t1 (* t1-bias proportion-in-t2)) \:other (* (- 1 t1-bias) proportion-in-t2)\\n              \:pair-function (fn [source1 source2] \\n                               ;; pair elts of 1st with elts of ()-padded 2nds\\n                               (map vector \\n                                    (ensure-list source1) \\n                                    (concat (ensure-list source2) \\n                                            (repeat ()))))\\n              \:mix-function (fn [whole1 whole2 params]\\n                              (let [include-1 (< (lrand) (\:self params))\\n                                    include-2 (< (lrand) (\:other params))]\\n                                (cond (and include-1\\n                                           (not include-2)) whole1\\n                                      (and (not include-1) \\n                                           include-2) whole2\\n                                      (and include-1\\n                                           include-2) (if (< (lrand) 0.5)\\n                                                        (combine whole1 whole2)\\n                                                        (combine whole2 whole1))\\n                                      ; nothing is implicit\\n                                      \:else ())))}))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(let [self 0.5\\n      other 0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 1000)\\n      [\:self s \:other o \:both b \:neither n]\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.5\\n      other 0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 10000)\\n      [\:self s \:other o \:both b \:neither n]\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.5\\n      other 0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      [\:self s \:other o \:both b \:neither n]\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.5\\n      other 0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o b)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.9 ;0.5\\n      other 0.1 ;0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o b)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.9 ;0.5\\n      other 0.1] ;0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o b)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.99 ;0.5\\n      other 0.01] ;0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o b)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.9 ;0.5\\n      other 0.25] ;0.5]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o b)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.9\\n      other 0.25\\n      ]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o b)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.9\\n      other 0.25\\n      ]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.5\\n      other 0.5\\n      ]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.99\\n      other 0.1\\n      ]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(let [self 0.99\\n      other 0.2\\n      ]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" ";; Switching to clojush.pushgp.genetic-operators namespace" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (+ (count-points t1) (count-points t2))) \\n            \:self 0.9\\n            \:other 0.2\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(hybridize-print (random-code-with-size 100 [1])\\n                 (random-code-with-size 100 [0]))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (+ (count-points t1) (count-points t2))) \\n            \:self 0.9\\n            \:other 0.3\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print (random-code-with-size 100 [1])\\n                 (random-code-with-size 100 [0]))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:whole (/ 1 (+ (count-points t1) (count-points t2))) \\n            \:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print (random-code-with-size 100 [1])\\n                 (random-code-with-size 100 [0]))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(count-points ())" "(defn shmix\\n  [self other params]\\n  (if (and (seq? self)\\n           (not (empty? self))\\n           (> (lrand) (/ 1 (count-points self))))\\n    (map (fn [[t1 t2]] (shmix t1 t2 params))\\n         ((\:pair-function params) self other))\\n    ((\:mix-function params) self other params)))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (insert-randomly whole1 whole2)\\n                                                      (insert-randomly whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  (remove-empties \\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))})))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n  ;(remove-empties \\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn shmix\\n  [self other params]\\n  (remove-empties\\n    (if (and (seq? self)\\n             (not (empty? self))\\n             (> (lrand) (/ 1 (count-points self))))\\n      (map (fn [[t1 t2]] (shmix t1 t2 params))\\n           ((\:pair-function params) self other))\\n      ((\:mix-function params) self other params))))" "(defn hybridize-print \\n  [a b]\\n  (println \\"b      \:\\" b)\\n  (println \\"a      \:\\" a)\\n  (println \\"hyb a b\:\\" (hybridize a b)))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn shmix\\n  [self other params]\\n  ;(remove-empties\\n    (if (and (seq? self)\\n             (not (empty? self))\\n             (> (lrand) (/ 1 (count-points self))))\\n      (map (fn [[t1 t2]] (shmix t1 t2 params))\\n           ((\:pair-function params) self other))\\n      ((\:mix-function params) self other params)))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.5\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)]\\n                             (map vector s1 (concat s2 (drop (count s2) s1)))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(defn shmix\\n  [self other params]\\n  ;(remove-empties\\n    (if (and (seq? self)\\n             (not (empty? self))\\n             (> (lrand) (/ 1 (count-points self))))\\n      (map (fn [[t1 t2]] (shmix t1 t2 params))\\n           ((\:pair-function params) self other))\\n      ((\:mix-function params) self other params)))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.2\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)]\\n                             (map vector s1 (concat s2 (drop (count s2) s1)))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.3\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)]\\n                             (map vector s1 (concat s2 (drop (count s2) s1)))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.75\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)]\\n                             (map vector s1 (concat s2 (drop (count s2) s1)))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn shmix\\n  [self other params]\\n  (remove-empties\\n    (if (and (seq? self)\\n             (not (empty? self))\\n             (> (lrand) (/ 1 (count-points self))))\\n      (map (fn [[t1 t2]] (shmix t1 t2 params))\\n           ((\:pair-function params) self other))\\n      ((\:mix-function params) self other params))))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.75\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             ;; pair elts of 1st with elts of ()-padded 2nds\\n                             (map vector \\n                                  (ensure-list source1) \\n                                  (concat (ensure-list source2) \\n                                          (repeat ()))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                             (map vector \\n                                  (concat s1 (repeat (max 0 (- s2-length s1-length)) ())\\n                                  (concat s2 (repeat (max 0 (- s1-length s2-length)) ()))))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn shmix\\n  [self other params]\\n  (remove-empties\\n    (if (and (seq? self)\\n             (not (empty? self))\\n             (> (lrand) (/ 1 (count-points self))))\\n      (map (fn [[t1 t2]] (shmix t1 t2 params))\\n           ((\:pair-function params) self other))\\n      ((\:mix-function params) self other params))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                             (map vector \\n                                  (concat s1 (repeat (max 0 (- s2-length s1-length)) ())\\n                                  (concat s2 (repeat (max 0 (- s1-length s2-length)) ()))))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(\= nil ())" "(defn p [thing] (println thing) thing)" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                             (p (map vector \\n                                  (concat s1 (repeat (max 0 (- s2-length s1-length)) ())\\n                                  (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(map vector '(1 2 3) '(a b c))" "(concat '(1 2 3) (repeat 2 ()))" "(ensure-list '(1 2 3))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (p (map vector \\n                                       (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                       (concat s2 (repeat (max 0 (- s1-length s2-length)) ()))))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.25\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (map vector \\n                                    (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                    (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 2/3\\n            \:other 1/3\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (map vector \\n                                    (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                    (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.99\\n            \:other 0.99\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (map vector \\n                                    (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                    (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.95\\n            \:other 0.05\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (map vector \\n                                    (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                    (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.3\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (map vector \\n                                    (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                    (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(hybridize-print (random-code-with-size 100 [1])\\n                 (random-code-with-size 100 [0]))" "(hybridize-print (random-code-with-size 70 [1])\\n                 (random-code-with-size 70 [0]))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(defn hybridize\\n  [t1 t2]\\n    (shmix t1\\n           t2\\n           {\:self 0.9\\n            \:other 0.1\\n            \:pair-function (fn [source1 source2] \\n                             (let [s1 (ensure-list source1)\\n                                   s2 (ensure-list source2)\\n                                   s1-length (count s1)\\n                                   s2-length (count s2)]\\n                               (map vector \\n                                    (concat s1 (repeat (max 0 (- s2-length s1-length)) ()))\\n                                    (concat s2 (repeat (max 0 (- s1-length s2-length)) ())))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2)\\n                                                      (combine whole2 whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(hybridize-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                 '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(let [self 0.9\\n      other 0.2\\n      ]\\n  (loop [i 0\\n         s 0\\n         o 0\\n         b 0\\n         n 0]\\n    (if (>\= i 100000)\\n      {\:self s \:other o \:both b \:neither n \:total (+ s o)}\\n      (let [chose-s (< (rand) self)\\n            chose-o (< (rand) other)]\\n        (recur (inc i)\\n               (if chose-s (inc s) s)\\n               (if chose-o (inc o) o)\\n               (if (and chose-s chose-o) (inc b) b)\\n               (if (not (or chose-s chose-o)) (inc n) n))))))" "(defn uniformly-crossover\\n  [t1 t2]\\n  (shmix t1\\n         t2\\n         {\:self 0.9\\n          \:other 0.2\\n          \:pair-function (fn [source1 source2] \\n                           (let [s1 (ensure-list source1)\\n                                 s2 (ensure-list source2)\\n                                 s1-length (count s1)\\n                                 s2-length (count s2)]\\n                             (map vector s1 (repeat s2))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))\\n                                  s2-subtree (code-at-point s2 (select-node-index s2))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) s2-subtree\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 s2-subtree)\\n                                                      (combine s2-subtree whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(defn uniformly-crossover\\n  [t1 t2]\\n  (shmix t1\\n         t2\\n         {\:self 0.9\\n          \:other 0.2\\n          \:pair-function (fn [source1 source2] \\n                           (let [s1 (ensure-list source1)\\n                                 s2 (ensure-list source2)\\n                                 s1-length (count s1)\\n                                 s2-length (count s2)]\\n                             (map vector s1 (repeat s2))))\\n            \:mix-function (fn [whole1 whole2 params]\\n                            (let [include-1 (< (lrand) (\:self params))\\n                                  include-2 (< (lrand) (\:other params))\\n                                  whole2-subtree (code-at-point whole2 (select-node-index whole2))]\\n                              (cond (and include-1\\n                                         (not include-2)) whole1\\n                                    (and (not include-1) \\n                                         include-2) whole2-subtree\\n                                    (and include-1\\n                                         include-2) (if (< (lrand) 0.5)\\n                                                      (combine whole1 whole2-subtree)\\n                                                      (combine whole2-subtree whole1))\\n                                    ; nothing is implicit\\n                                    \:else ())))}))" "(defn uniformly-crossover-print \\n  [a b]\\n  (println \\"b      \:\\" b)\\n  (println \\"a      \:\\" a)\\n  (println \\"uxo a b\:\\" (uniformly-crossover a b)))" "(uniformly-crossover-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                           '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(uniformly-crossover-print '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23))\\n                           '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z))))))" "(uniformly-crossover-print '(a (b ((c d) e) f (g h i (j k l) ((m n o p q r) s t u v ((w) x y z)))))\\n                           '((1 2) 3 (4 ((5)) 6 7 8 9 10 11)(12 13 14 (15 16 17 18)(19 20) 21 22 23)))" "(uniformly-crossover-print (random-code-with-size 70 [1])\\n                           (random-code-with-size 70 [0]))" "(defn combine [t1 t2] \\n  \\"Returns a list containing all of the elements of t1 and t2, after making each into\\na list if necessary.\\"\\n  (apply list (concat (ensure-list t1) (ensure-list t2))))" "(combine () '(1 2 3))" "(combine 1 '(3 4))" ";; Switching to clojush.experimental.calc namespace" "(/ 2 18.0)" "(/ 3 19.0)" "(/ 1 19.0)" "(/ 1 21.0)" "(/ 2 22.0)" "(/ 3 23.0)" "(/ 20 30.0)" "(dotimes [i (take 100 (iterate inc 0))]\\n  (println i (/ (Math/abs (- i 10)) (+ (Math/abs i) (Math/abs 10)))))" "(for [i (take 100 (iterate inc 0))]\\n     (println i (/ (Math/abs (- i 10)) (+ (Math/abs i) (Math/abs 10)))))" "(for [i (take 100 (iterate inc 0))]\\n        (println i (float (/ (Math/abs (- i 10)) (+ (Math/abs i) (Math/abs 10))))))" "(for [i (take 100 (iterate \#(+ % 10) 0))]\\n        (println i (/ (Math/abs (- i 10)) (+ (Math/abs i) (Math/abs 10)))))" "(for [i (take 100 (iterate \#(+ % 10) 0))]\\n           (println i (float (/ (Math/abs (- i 10)) (+ (Math/abs i) (Math/abs 10))))))" "(Math/pow 2 10)" "(Math/pow 0.9 10)"]
eclipse.preferences.version=1
